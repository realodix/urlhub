<?php

namespace Tests\Unit\Services;

use App\Exceptions\CouldNotGenerateUniqueKeyException;
use App\Models\Url;
use App\Services\BlockedStringService;
use App\Services\KeyGeneratorService;
use Illuminate\Support\Facades\File;
use PHPUnit\Framework\Attributes as PHPUnit;
use Tests\TestCase;

#[PHPUnit\Group('services')]
class KeyGeneratorServiceTest extends TestCase
{
    private const RESOURCE_PREFIX = 'zzz';

    private KeyGeneratorService $keyGen;

    private BlockedStringService $blocked;

    protected function setUp(): void
    {
        parent::setUp();

        $this->keyGen = app(KeyGeneratorService::class);
        $this->blocked = app(BlockedStringService::class);
    }

    public function testGenerateUniqueString(): void
    {
        $value = 'foo';

        // Scenario 1
        $hash = $this->keyGen->generate($value);
        $this->assertSame($this->keyGen->shortHash($value), $hash);

        // Scenario 2
        // If the string is already used as a short link keyword
        Url::factory()->create(['keyword' => $hash]);
        $mock = $this->partialMock(KeyGeneratorService::class);
        $mock->shouldReceive([
            'shortHash' => $hash,
            'randomString' => 'mocked_random_string',
        ]);

        $this->assertSame('mocked_random_string', $mock->generate($value));
    }

    /**
     * Tests the scenario when a reserved keyword is used as a value for the
     * generation of a unique string. The random string should be used instead
     * of the reserved keyword.
     */
    public function testGenerateUniqueStringWithReservedKeyword(): void
    {
        $reserved_keyword = KeyGeneratorService::RESERVED_KEYWORD[0];

        $mock = $this->partialMock(KeyGeneratorService::class);
        $mock->shouldReceive([
            'shortHash' => $reserved_keyword,
            'randomString' => 'mocked_random_string',
        ]);

        $this->assertSame(
            'mocked_random_string',
            $mock->generate($reserved_keyword),
        );
    }

    /**
     * Tests the scenario when a blacklisted string is used as a value for the
     * generation of a unique string. The random string should be used instead
     * of the blacklisted string.
     */
    public function testGenerateUniqueStringWithBlacklistedString(): void
    {
        $blacklisted_string = 'blacklisted_keyword';
        config(['urlhub.blacklist_keyword' => [$blacklisted_string]]);

        $mock = $this->partialMock(KeyGeneratorService::class);
        $mock->shouldReceive([
            'shortHash' => $blacklisted_string,
            'randomString' => 'mocked_random_string',
        ]);

        $this->assertSame(
            'mocked_random_string',
            $mock->generate($blacklisted_string),
        );
    }

    /**
     * The length of the string generated by the generator is adjustable
     */
    public function testGeneratedKeyLengthMatchesConfiguration(): void
    {
        $inputString = 'foobar';
        $strLen = 8;
        settings()->fill(['key_len' => $strLen])->save();

        $actual = $this->keyGen->generate($inputString);
        $this->assertSame($strLen, strlen($actual));
        $this->assertNotSame(strlen($inputString), strlen($actual));
    }

    #[PHPUnit\Test]
    public function generateThrowsExceptionIfUniqueKeyCannotBeFoundAfterMaxAttempts(): void
    {
        $this->expectException(CouldNotGenerateUniqueKeyException::class);

        $keyGenMock = $this->partialMock(KeyGeneratorService::class);

        // 1. Ensure the initial shortHash is considered "already taken"
        $keyGenMock->shouldReceive('shortHash')->once()->andReturn('taken_initial_hash');

        // 2. Ensure verify() always returns false, forcing the loop to continue.
        //    This will be called for 'taken_initial_hash' first, then for the random string.
        $keyGenMock->shouldReceive('verify')->andReturn(false);

        // 3. We expect randomString() to be called MAX_RANDOM_STRING_ATTEMPTS times
        //    before the exception is thrown.
        $keyGenMock->shouldReceive('randomString')
            ->times(KeyGeneratorService::MAX_RANDOM_STRING_ATTEMPTS)
            // The actual return value is not very important here because verify is mocked
            ->andReturn('any_random_string');

        $keyGenMock->generate('some_long_url');
    }

    /**
     * The `verify` function should return `false` when the string is already
     * used as a short link keyword
     */
    #[PHPUnit\Test]
    public function verify_stringIsAlreadyInUse(): void
    {
        $standardKey = 'fOo';
        Url::factory()->create(['keyword' => $standardKey, 'is_custom' => false]);
        $this->assertFalse($this->keyGen->verify($standardKey));
        $this->assertTrue($this->keyGen->verify(strtoupper($standardKey)));
        $this->assertTrue($this->keyGen->verify(strtolower($standardKey)));

        $customeKey = 'bAr';
        Url::factory()->create(['keyword' => $customeKey, 'is_custom' => true]);
        $this->assertFalse($this->keyGen->verify($customeKey));
        $this->assertFalse($this->keyGen->verify(strtoupper($customeKey)));
        $this->assertFalse($this->keyGen->verify(strtolower($customeKey)));
    }

    /**
     * The `verify` function should return `false` when the string is in
     * the disallow list.
     */
    #[PHPUnit\Test]
    public function verify_stringIsDisallowed(): void
    {
        // Reserved
        $value = KeyGeneratorService::RESERVED_KEYWORD[0];
        $this->assertFalse($this->keyGen->verify($value));
        $this->assertFalse($this->keyGen->verify(strtoupper($value)));

        // Blacklisted
        $value = 'foobar';
        config(['urlhub.blacklist_keyword' => [$value]]);
        $this->assertFalse($this->keyGen->verify($value));
        $this->assertFalse($this->keyGen->verify(strtoupper($value)));

        // Route
        $value = $this->blocked->routeList()->first();
        $this->assertFalse($this->keyGen->verify($value));
        $this->assertFalse($this->keyGen->verify(strtoupper($value)));

        // Public directory
        $value = self::RESOURCE_PREFIX.fake()->word();
        File::makeDirectory(public_path($value));
        $this->assertFalse($this->keyGen->verify($value));
        $this->assertFalse($this->keyGen->verify(strtoupper($value)));

        // File name in public directory
        $value = self::RESOURCE_PREFIX.fake()->word();
        File::put(public_path($value), '');
        $this->assertFalse($this->keyGen->verify($value));
        $this->assertFalse($this->keyGen->verify(strtoupper($value)));
    }

    /**
     * Test the identification of active keywords that are also disallowed.
     *
     * This test verifies that the `disallowedKeywordsInUse` method accurately
     * finds keywords that are currently in use but are also on the disallowed
     * list.
     *
     * It checks two primary scenarios:
     * 1. When no disallowed keywords are in use, the method should return
     *    an empty list.
     * 2. When some disallowed keywords are actively in use, the method should
     *    return a list containing only those keywords.
     */
    #[PHPUnit\Test]
    public function disallowed_keywordInUse()
    {
        // Test case 1: No reserved keywords already in use
        $this->assertEmpty($this->keyGen->disallowedKeywordsInUse()->all());

        // Test case 2: Some reserved keywords already in use
        $keywordLowerCase = 'laravel';
        $keywordUpperCase = 'Laravel';
        $otherKeyword = 'some_other_keyword';
        Url::factory()->create(['keyword' => $keywordLowerCase]);
        Url::factory()->create(['keyword' => $keywordUpperCase]);
        Url::factory()->create(['keyword' => $otherKeyword]);
        config(['urlhub.blacklist_keyword' => [$keywordLowerCase]]);

        $this->assertEqualsCanonicalizing(
            [$keywordLowerCase, $keywordUpperCase],
            $this->keyGen->disallowedKeywordsInUse()->all(),
        );
    }

    #[PHPUnit\Test]
    public function totalKeywordSpaceUsed(): void
    {
        $keyLen = 3;

        settings()->fill(['key_len' => $keyLen])->save();
        Url::factory()->create(['keyword' => 'foo', 'is_custom' => false]); // 1
        Url::factory()->create(['keyword' => 'bar', 'is_custom' => true]); // 8
        $this->assertSame(9, $this->keyGen->totalKeywordSpaceUsed());

        // Character length does not meet criteria
        settings()->fill(['key_len' => $keyLen + 1])->save();
        $this->assertSame(0, $this->keyGen->totalKeywordSpaceUsed());
        settings()->fill(['key_len' => $keyLen - 1])->save();
        $this->assertSame(0, $this->keyGen->totalKeywordSpaceUsed());
    }

    #[PHPUnit\Test]
    public function standardKeywordSpaceUsed(): void
    {
        $keyLen = 3;

        settings()->fill(['key_len' => $keyLen])->save();
        Url::factory()->create(['keyword' => 'foo', 'is_custom' => false]);
        Url::factory()->create(['keyword' => 'bar', 'is_custom' => false]);
        $this->assertSame(2, $this->keyGen->standardKeywordSpaceUsed());

        // Character length does not meet criteria
        settings()->fill(['key_len' => $keyLen + 1])->save();
        $this->assertSame(0, $this->keyGen->standardKeywordSpaceUsed());
        settings()->fill(['key_len' => $keyLen - 1])->save();
        $this->assertSame(0, $this->keyGen->standardKeywordSpaceUsed());
    }

    #[PHPUnit\Test]
    public function customKeywordSpaceUsed(): void
    {
        $keyLen = 3;

        settings()->fill(['key_len' => $keyLen])->save();
        Url::factory()->create(['keyword' => 'abc', 'is_custom' => true]); // 8
        Url::factory()->create(['keyword' => 'a2c', 'is_custom' => true]); // 4
        Url::factory()->create(['keyword' => 'a-c', 'is_custom' => true]); // 4
        Url::factory()->create(['keyword' => 'a2-', 'is_custom' => true]); // 2
        Url::factory()->create(['keyword' => '-12', 'is_custom' => true]); // 1
        $this->assertSame(19, $this->keyGen->customKeywordSpaceUsed());

        // Character length does not meet criteria
        settings()->fill(['key_len' => $keyLen + 1])->save();
        $this->assertSame(0, $this->keyGen->customKeywordSpaceUsed());
        settings()->fill(['key_len' => $keyLen - 1])->save();
        $this->assertSame(0, $this->keyGen->customKeywordSpaceUsed());
    }

    #[PHPUnit\Test]
    #[PHPUnit\TestWith([2, 1, 1])]
    #[PHPUnit\TestWith([1, 2, 0])] // negative value
    public function capacity($max, $used, $expected): void
    {
        $mock = $this->partialMock(KeyGeneratorService::class);
        $mock->shouldReceive([
            'maxUniqueStrings' => $max,
            'disallowedKeywordSpaceUsed' => $used,
        ]);
        $actual = $mock->remainingCapacity();

        $this->assertSame($expected, $actual);
    }

    #[PHPUnit\Test]
    #[PHPUnit\TestWith([1, 2, 0])]
    #[PHPUnit\TestWith([3, 2, 1])]
    #[PHPUnit\TestWith([100, 99, 1])]
    #[PHPUnit\TestWith([100, 20, 80])]
    #[PHPUnit\TestWith([100, 100, 0])]
    public function remainingCapacity($capacity, $used, $expected): void
    {
        $mock = $this->partialMock(KeyGeneratorService::class);
        $mock->shouldReceive([
            'capacity' => $capacity,
            'totalKeywordSpaceUsed' => $used,
        ]);
        $actual = $mock->remainingCapacity();

        $this->assertSame($expected, $actual);
    }

    /**
     * Test calculation of maximum unique strings based on key length.
     *
     * Verifies that `maxUniqueStrings` correctly calculates the total possible
     * combinations for a short key length and returns `PHP_INT_MAX` when the
     * calculation would exceed the maximum integer value (tested with a long
     * key length).
     */
    #[PHPUnit\Test]
    public function maxUniqueStrings(): void
    {
        $charLen = strlen($this->keyGen::ALPHABET);

        // Test case 1: Short key length
        settings()->fill(['key_len' => 2])->save();
        $this->assertSame(pow($charLen, 2), $this->keyGen->maxUniqueStrings());

        // Test case 2: Long key length
        settings()->fill(['key_len' => 12])->save();
        $this->assertSame(PHP_INT_MAX, $this->keyGen->maxUniqueStrings());
    }

    #[PHPUnit\Test]
    public function disallowedKeywordSpaceUsed(): void
    {
        settings()->fill(['key_len' => 2])->save();

        $mock = $this->partialMock(KeyGeneratorService::class);
        $mock->shouldReceive([
            'routeCollisionList' => ['ab', 'foo'],
            'publicPathCollisionList' => ['cd', 'bar'],
        ]);
        $actual = $mock->disallowedKeywordSpaceUsed();

        // (2^2) * 2
        $this->assertSame(8, $actual);
    }

    public function tearDown(): void
    {
        $resources = File::glob(public_path(self::RESOURCE_PREFIX.'*'));
        foreach ($resources as $resource) {
            File::deleteDirectory($resource);
            File::delete($resource);
        }

        parent::tearDown();
    }
}
